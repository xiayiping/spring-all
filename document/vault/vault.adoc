
[source,text]
----

Unseal Key 1: pu/Vc+J5QPv/YudjZ22xXqC2cuQ4pJZRS0bmiPpa1ev6
Unseal Key 2: p5fnNgd6zD+wUZhqXj1JG6eFebrIDfTKEQS/BzreKTDF
Unseal Key 3: tl8e0G3xGa5GmgGqmAfzJ2l9fcdwddZYmYEOjkmp9pHA
Unseal Key 4: Bc0+9oPU7b0Ilp+pl5BN5jNmAd5YH9UOUDlcW7TsPITI
Unseal Key 5: sTtQtBZOxf7jQ8/hjqIYMGcKlG0W4f9QK0zrrlFv0A18

Initial Root Token: hvs.6SnLsAKoGIyHE4sE5NtRvk0b


PS C:\Users\terry.xiao> vault token create -policy=matt_policy
Key Value
--- -----
token hvs.CAESIOuIuBjV-viraSq1zb6A7F5Aeg4icLbz9HyfEXTZMlaXGh4KHGh2cy5EWFNadDVOM1VtbEJkUWhIb1FpZjQ3QU4
token_accessor vnOOvwwoDBV3c7fpOZse8rru
token_duration 768h
token_renewable true
token_policies ["default" "matt_policy"]
identity_policies []
policies ["default" "matt_policy"]

PS C:\Users\terry.xiao> vault token create -policy="admin" -period=168h
Key Value
--- -----
token hvs.CAESIAsnldj83JZesIIIjJFRbb57M2thM79K2ewpn8Irvl9yGh4KHGh2cy5XMm1sUTl4cjczNVJjNkswTWZ6YkZDcmM
token_accessor q96WMwFxTno4Kheh34rrgnbu
token_duration 168h
token_renewable true
token_policies ["admin" "default"]
identity_policies []
policies ["admin" "default"]

export VAULT_ADDR='https://vault.tcghl.com'
vault token revoke -self -ca-path=./ca.pem
vault print token

dev_paradise_kv_read
Key                  Value
---                  -----
token                hvs.CAESIKD7uAwveSXkWUzsQGtBdZ2vi9Q3CQODKX8WSYkS-rHFGh4KHGh2cy5MUGZ4dXJJeXAzOFVzR2NjM0tRTmRpOFg
token_accessor       23oHfMgFap5DOuuJQXWRzyAX
token_duration       768h
token_renewable      true
token_policies       ["default" "dev_paradise_kv_read"]
identity_policies    []
policies             ["default" "dev_paradise_kv_read"]


hvs.CAESIG0b0zwrmDV5_kJAw4OIfOLqSRSm5JR9DROreORe8sNhGh4KHGh2cy5ram9UYkdxeVlQMGRBTE1XVjcwSXV1VEU


vault_token : "hvs.CAESIG0b0zwrmDV5_kJAw4OIfOLqSRSm5JR9DROreORe8sNhGh4KHGh2cy5ram9UYkdxeVlQMGRBTE1XVjcwSXV1VEU"

you can put $vault_token in system environment  ,
it's the highest priority token.
2nd priority is ~/.vault.token file.

----

[source,text]
----
## the vault config file sample

listener "tcp" {
  address = "0.0.0.0:8180"
  #tls_disable = 1
  tls_cert_file = "d:/tools/vault/1.14/ca.pem"
  tls_key_file = "d:/tools/vault/1.14/ca-key.pem"
}

ui=true

#storage "inmem" {}

storage "file" {
  path = "d:/tools/vault/vault-data"
}

api_addr = "https://127.0.0.1:8180"
----

[source,shell]
----
# start vault
vault server -config=config.file.name
----

[source,shell]
----
# the first time you need to use vault
export VAULT_ADDR='https://127.0.0.1:8180'
export vault_token=hvs.6SnLsAKoGIyHE4sE5NtRvk0b
export ca="-ca-path=./ca.pem"
vault kv get $ca -format=json kv_xyp/dev

export VAULT_ADDR=https://vault.tcghl.com
export vault_token="hvs.CAESIBFEm5eW69K608ugiQzDC3Vx8J2_TLoC24V_EfSzrGWsGh4KHGh2cy5PSEQ4WUU4c3BIaEU4dERBbmdLallscW4"
export vault_token="hvs.CAESIEzY-4tf7ndPdQZslaCdZSDJuBlmus0_E4go-DV5uoBrGh4KHGh2cy5CdzBac1FaS0tQVzRqUGt5VWZpaDNHT3U"
export ca="-ca-path=D:/develop/tcg-paradise/template/config/resources/vault.pem"
vault kv get $ca -format=json dev/paradise/keystore

vault token create -ca-path=./ca.pem -policy=kv_read

vault login -ca-path=D:/develop/tcg-paradise/template/config/resources/vault.pem
----

[source,shell]
----
vault login -ca-path=./ca.pem
#then provide the token

vault token create -ca-path=./ca.pem -policy=kv_read
# then vault will give you the token
# hvs.CAESIH66nAoa6gU05CN1CIpKIpaP3pkNYM2gbMEjmo7szQ4WGh4KHGh2cy4wQlB3Z25tMnFFS2NodjhPZzhpak9XSkQ
----

[source,shell]
----


# assume you have k-v username=aaaa under kv_xyp/dev
# kv_xyp is the kv engine path, dev is the secret path
vault kv get --field=username kv_xyp/dev

# you want a url , you do this:
vault kv get --field=username  -output-curl-string kv_xyp/dev

curl\
  -H "X-Vault-Request: true"\
  -H "X-Vault-Token: hvs.6SnLsAKoGIyHE4sE5NtRvk0b"\
  https://127.0.0.1:8180/v1/kv_xyp/data/dev

## --cert /path/to/cert.pem
----

[source,text]
----
# config the policy

path "kv_xyp/*" {
    capabilities = ["read"]
}

path "pki_xyp_int/*" {
  capabilities = ["read","create","update"]
}

path "pki_xyp/*" {
  capabilities = ["read","create","update"]
}

----

=== Generate Root CA
[source,shell]
----
# vault pki
export pki_path=pki_xyp
export v_ca=./ca.pem
export vca="-ca-path=./ca.pem"

vault secrets enable -ca-path=${v_ca} -path ${pki_path} pki
vault secrets tune -max-lease-ttl=87600h -ca-path=${v_ca} ${pki_path}

## for all names, refer to https://developer.hashicorp.com/vault/api-docs/secret/pki
vault write \
     -field=certificate \
     -ca-path=${v_ca} \
     ${pki_path}/root/generate/internal \
     common_name="xyp.com" \
     issuer_name="root-2023" \
     ttl=87600h > root_2023_ca.crt

## check issuer:
vault list -ca-path=${v_ca} ${pki_path}/issuers/
vault list -ca-path=${v_ca} -format=json  ${pki_path}/issuers/

vault read -ca-path=${v_ca} \
  ${pki_path}/issuer/6168f63c-f718-c39a-47f6-2b35137c8767

vault read -ca-path=${v_ca} \
  ${pki_path}/issuer/$(vault list -ca-path=${v_ca} \
                        -format=json ${pki_path}/issuers/ \
                        | jq -r '.[0]') \
                    | tail -n 6
### ckeck done

# create role
export pki_role=2023-servers
vault write -ca-path=${v_ca} ${pki_path}/roles/${pki_role} allow_any_name=true

## ca and crl urls
vault write -ca-path=${v_ca} \
     ${pki_path}/config/urls \
     issuing_certificates="${VAULT_ADDR}/v1/${pki_path}/ca" \
     crl_distribution_points="${VAULT_ADDR}/v1/${pki_path}/crl"

----

=== Generate Intermediate Certificate
[source,shell]
----
export pki_path=pki_xyp
export pki_int_path=pki_xyp_int
export v_ca=./ca.pem
export cert_role=example-dot-com

## create a new path
vault secrets enable -ca-path=${v_ca} -path=${pki_int_path} pki
vault secrets tune -ca-path=${v_ca} -max-lease-ttl=43800h ${pki_int_path}

## create csr,
# nothing uploaded to vault in this step
vault write -ca-path=${v_ca} \
    -format=json \
    ${pki_int_path}/intermediate/generate/internal \
    common_name="xyp2.com Intermediate Authority" \
    issuer_name="xyp-dot-com-intermediate" \
    | jq -r '.data.csr' > pki_intermediate.csr
## check
openssl req -in ./pki_intermediate.csr -text -noout
## check done

## sign the csr, the csr=@ is followed by the file name
## this step will create a certificate in the root-ca's path
vault write -ca-path=${v_ca} \
    -format=json \
    ${pki_path}/root/sign-intermediate \
    issuer_ref="root-2023" \
    csr=@pki_intermediate.csr \
    format=pem_bundle ttl="43800h" \
    | jq -r '.data.certificate' > intermediate.cert.pem
## check
openssl x509 -in ./intermediate.cert.pem -text -noout
## check done
##########################

# input back to vault under intermediate path
# this will add an issuer to the path
vault write -ca-path=${v_ca} \
    ${pki_int_path}/intermediate/set-signed \
    certificate=@intermediate.cert.pem

----

=== Now create leaf certificate from Intermediate Certificate
[source,shell]
----
## create the role
export cert_role=example-dot-com
vault write -ca-path=${v_ca} \
    ${pki_int_path}/roles/${cert_role} \
    issuer_ref="$(vault read -ca-path=${v_ca} \
                  -field=default ${pki_int_path}/config/issuers)" \
    allowed_domains="xypexample.com" \
    allow_subdomains=true \
    max_ttl="720h"

## request certificates
vault write -ca-path=${v_ca} \
    ${pki_int_path}/issue/${cert_role} common_name="test.xypexample.com" ttl="24h"
## you'll find the certificate created under ${pki_int_path}
vault write -ca-path=${v_ca} \
    ${pki_int_path}/issue/${cert_role} common_name="test2.xypexample.com" ttl="2400h"
vault write -ca-path=${v_ca} \
    ${pki_int_path}/issue/${cert_role} common_name="test3.xypexample.com" ttl="2400h"
vault write -ca-path=${v_ca} \
    ${pki_int_path}/issue/${cert_role} common_name="test4.xypexample.com" \
    ip_sans="127.0.0.1,192.168.0.1" \
    alt_names="tt4.xypexample.com,aa4.xypexample.com,localhost"
    ttl="2400h"

## issue with dedicated rol "issuer_role"
vault write -ca-path=${v_ca} \
    ${pki_path}/issue/issuer_role common_name="test4.xypexample.com" \
    -format=json \
    ip_sans="127.0.0.1,192.168.0.1" \
    alt_names="tt4.xypexample.com,aa4.xypexample.com,localhost"
    ttl="24000h"
----

==== create a new role for non-default issuer under same engine
[source,shell]
----

# vault pki
export pki_path=paradise_dev
export v_ca=./tcghl-com-crt.pem
export vca="-ca-path=./tcghl-com-crt.pem"
export root_issuer_role=root_issuer
export root_issuer_name="paradise_dev_root_issuer"
export issuer_role=paradise_issuer
export issuer_name="paradise_dev_issuer"
export vault_kv_mount=secret
export vault_kv_path=dev/paradise/keystore

## max ttl 10 years
vault secrets enable -ca-path=${v_ca} -path ${pki_path} pki
vault secrets tune -max-lease-ttl=87600h -ca-path=${v_ca} ${pki_path}

# the root certificate
vault write \
     -field=certificate \
     -ca-path=${v_ca} \
     ${pki_path}/root/generate/internal \
     common_name="tcg.com" \
     issuer_name="${root_issuer_name}" \
     ttl=87600h > root_ca.crt
cat root_ca.crt

# create role
vault write -ca-path=${v_ca} ${pki_path}/roles/${root_issuer_role} \
  allow_any_name=true \
  allow_ip_sans=false

## so far no need CRL
########################################################### ROOT done

### now create Intermediate certificate
# csr
vault write -ca-path=${v_ca} \
    -format=json \
    ${pki_path}/intermediate/generate/internal \
    common_name="Paradise_TCG9" \
    issuer_name="${issuer_name}" > csr_req.json
cat csr_req.json
cat csr_req.json | jq -r '.data.csr' > tcg_intermediate.csr

# sign
## this step will create a certificate in the root-ca's path
vault write -ca-path=${v_ca} \
    -format=json \
    ${pki_path}/root/sign-intermediate \
    issuer_ref="${root_issuer_name}" \
    csr=@tcg_intermediate.csr \
    format=pem_bundle ttl="44000h" > sign_req.json
cat sign_req.json
cat sign_req.json | jq -r '.data.certificate' > intermediate.cert.pem


# write to pki
vault write -ca-path=${v_ca} \
    -format=json \
    ${pki_path}/intermediate/set-signed \
    certificate=@intermediate.cert.pem > sign.json
cat ./sign.json | jq -r .data.imported_issuers[0]
export issuer_name=$(cat ./sign.json | jq -r .data.imported_issuers[0])

# https://developer.hashicorp.com/vault/api-docs/secret/pki#create-update-role
## create role with specified issuer ,
## issuer_role2 is the role name
vault write -ca-path=${v_ca} \
  ${pki_path}/roles/${issuer_role} \
  allow_any_name=true \
  allow_ip_sans=false \
  issuer_ref="${issuer_name}"

## issue the certificate
#    ip_sans="127.0.0.1" \
## this will return you the private key and certificate
vault write -ca-path=${v_ca} \
    ${pki_path}/issue/${issuer_role} \
    common_name="paradise.tcg.com" \
    -format=json \
    alt_names="tcg.com,tcghl.com,*.tcg.com,*.tcghl.com,localhost" \
    ttl="43800h" | tee leaf_cert.json

cat ./leaf_cert.json | jq -r .data.private_key > pk.pem
cat ./leaf_cert.json | jq -r .data.certificate > cert.pem
cat ./leaf_cert.json | jq -r .data.issuing_ca > issuer.pem
cat pk.pem > key_store.pem
cat cert.pem > cert_chain.pem
cat issuer.pem >> cert_chain.pem

openssl x509 -in ./cert.pem -text -noout
openssl x509 -in ./issuer.pem -text -noout

rm ./keystore2.p12
openssl pkcs12 -export -in cert_chain.pem -inkey pk.pem -out keystore2.p12 -name "server-key2"
keytool -list -v -keystore ./keystore2.p12

vault list -ca-path=${v_ca} -format=json ${pki_path}/issuers/
export root_issuer_id=$(vault read -ca-path=${v_ca}   -format=json   ${pki_path}/issuer/${root_issuer_name} \
   | jq -r .data.issuer_id)

## the root CA
vault read -ca-path=${v_ca} \
  -format=json \
  ${pki_path}/issuer/${root_issuer_id} | jq -r .data.certificate > root-ca.pem
cat root-ca.pem

rm ./truststore2.p12
keytool -import -alias server-trust -file ./root-ca.pem -keystore ./truststore2.p12

#export vault_kv_mount=secret
#export vault_kv_path=dev/paradise/keystore

vault kv get ${vca} -mount=${vault_kv_mount} --field=password ${vault_kv_path}

## use 'path' !!!!
## if use 'put', the whole k-v in the path will be removed, only the put one be kept.
echo "nacos" | vault kv patch ${vca} -mount=${vault_kv_mount} ${vault_kv_path} npassword=-

# add -w 0 to avoid new line break
base64 -w 0 ./keystore2.p12   | vault kv patch ${vca} -mount=${vault_kv_mount} ${vault_kv_path} key_store_2=-
base64 -w 0 ./truststore2.p12 | vault kv patch ${vca} -mount=${vault_kv_mount} ${vault_kv_path} trust_store_2=-
# add head -c -1 | to avoid last line that breaks the
echo "123456" | head -c -1 | vault kv patch ${vca} -mount=${vault_kv_mount} ${vault_kv_path} password=-

----


[source,shell]
----
## use certificate in application
# create policy
export policy=certs_int

echo "path \"${pki_int_path}/*\" {
  capabilities = [\"read\",\"create\",\"update\"]
}" > ${policy}.hcl
cat ${policy}.hcl | vault policy write -ca-path=${v_ca}  ${policy} -

----

[source,shell]
----
## get certs
vault list -ca-path=./ca.pem pki_xyp/certs
vault read -ca-path=./ca.pem -format=json \
    -output-curl-string \
    pki_xyp/cert/09:d7:a4:5d:3c:df:bd:62:d3:42:a6:ca:e0:5e:23:39:89:5e:0e:3b
vault read -ca-path=./ca.pem -format=json \
    pki_xyp/cert/09:d7:a4:5d:3c:df:bd:62:d3:42:a6:ca:e0:5e:23:39:89:5e:0e:3b
vault read -ca-path=./ca.pem -format=json \
    pki_xyp_int/cert/75:39:5a:f4:8e:5c:75:1a:e1:c8:56:76:99:01:c1:54:d7:90:92:e1

----

https://www.hashicorp.com/blog/certificate-management-with-vault


== practice

=== CA ROOT
[source, shell]
----
## PKI means Public Key Infrastructure
export pki_path="pki/xyp"
vault secrets disable ${pki_path}
# can the secrets engine name contains '/' ?
vault secrets enable -path=${pki_path} pki
vault secrets tune -max-lease-ttl=3650d  -description="localhost certificate" ${pki_path}
vault write -format=json ${pki_path}/root/generate/internal common_name=myvault.com ttl=3650d   # must be /root/generate/internal ? YES !
# When you enable a secrets engine in Vault, you specify a mount path. All operations for that secrets engine are relative to this mount path.
# For example, if you mount the PKI secrets engine at the default path pki/, the full path to generate a root certificate becomes pki/root/generate/internal.

# if you access below 2 urls, vault will make you down load the cer and crl files.
# the the url of the file is FIXED, so that's wired, probably you can keep the file on your own web-site rather than vaults'
vault write -format=json ${pki_path}/config/urls issuing_certificates="${VAULT_ADDR}/v1/${pki_path}/ca" crl_distribution_points="${VAULT_ADDR}/${pki_path}/crl"

# issuer commands
## below will create a new issuer, comment out to avoid really create
#vault write ${pki_path}/root/generate/internal common_name='127.0.0.1' ttl=3650d
# list issuers (root certificate)
vault list -format=json ${pki_path}/issuers
vault read -format=json ${pki_path}/issuer/$(vault list -format=json ${pki_path}/issuers | jq -r '.[0]' )
vault read -format=json ${pki_path}/issuer/$(vault list -format=json ${pki_path}/issuers | jq -r '.[0]' ) | jq -r '.data.certificate' | openssl x509 -text -noout
## when you create a root certificate, you create an issuer at the mean time.


# Configure a role
export role_name='example-localhost'
vault write -format=json ${pki_path}/roles/${role_name} allowed_domains='myvault.com' allow_subdomains=true allow_ip_sans=true max_ttl=72h
# role issue certificate, will issue a cert directly under root ca, so comment it out
#vault write ${pki_path}/issue/${role_name} common_name=abc.myvault.com ip_sans='127.0.0.1,192.168.1.1'

#################################

## delete issuer
## https://developer.hashicorp.com/vault/api-docs/secret/pki#delete-issuer
vault delete ${pki_path}/issuer/88b7dbb8-e226-fd1f-e45c-72c0d6e3ce80
## set default issuer
vault write $pki_path/config/issuers default=2c556a8e-50a2-f554-4422-784981155811

## revoke certificate
vault list ${pki_path}/certs
vault write ${pki_path}/revoke serial_number=77:73:c1:18:ab:59:0d:3c:e2:ee:f6:f0:b0:e6:ad:5c:e3:4f:57:1f
vault delete ${pki_path}/certs/77:73:c1:18:ab:59:0d:3c:e2:ee:f6:f0:b0:e6:ad:5c:e3:4f:57:1f
----

=== CA INTERMEDIATE
[source,shell]
----
export pki_int_path="pki/xyp-int"
vault secrets disable ${pki_int_path}
vault secrets enable -path=${pki_int_path} pki
# can't use pki/xyp/int ,  path is already in use at pki/xyp/

vault secrets tune -max-lease-ttl=3650d ${pki_int_path}

vault write -format=json ${pki_int_path}/config/urls issuing_certificates="${VAULT_ADDR}/v1/${pki_int_path}/ca" crl_distribution_points="${VAULT_ADDR}/${pki_int_path}/crl"

# create the key
vault write -format=json ${pki_int_path}/intermediate/generate/internal common_name="myvault.com Intermediate Authority" ttl=43800h > key.resp.json
cat ./key.resp.json
cat ./key.resp.json | jq -r '.data.csr'
cat ./key.resp.json | jq -r '.data.csr' > pki_int.csr

#Take the signing request from the intermediate authority and sign it using another certificate authority, in this case the root certificate authority generated in the first example.
vault write -format=json ${pki_path}/root/sign-intermediate csr=@pki_int.csr format=pem_bundle ttl=43800h > signed.json
cat ./signed.json | jq -r '.data.certificate'
cat ./signed.json | jq -r '.data.certificate' > signed_cert.pem
#Now set the intermediate certificate authorities signing certificate to the root-signed certificate.
vault write -format=json ${pki_int_path}/intermediate/set-signed certificate=@signed_cert.pem

# create role
#     allowed_domains="myvault.com" \
export role_name_int='int-localhost'
vault write -format=json ${pki_int_path}/roles/${role_name_int} \
    issuer_ref="$(vault read -field=default ${pki_int_path}/config/issuers)" \
    allow_subdomains=true \
    allowed_domains=myvault.com \
    allow_ip_sans=true \
    max_ttl="720h"

#vault delete  ${pki_int_path}/roles/example-dot-com

# issue certificate
vault write -format=json ${pki_int_path}/issue/${role_name_int} \
    common_name=blah.myvault.com \
    ip_sans='127.0.0.1,192.168.1.1' > leaf.cert.json

----